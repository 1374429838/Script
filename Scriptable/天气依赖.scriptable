{
  "always_run_in_app" : false,
  "icon" : {
    "color" : "cyan",
    "glyph" : "burn"
  },
  "name" : "天气依赖",
  "script" : "\/* ------------------------------------------\nScript      : 开发环境\nDescription : 仅支持锁屏天气脚本调用\nDocs        : gitee.com\/script_djg\/scriptable\n------------------------------------------ *\/\n\nconst RUNTIME_VERSION = \"1.0\"\n\nclass DJG {\n  constructor(arg) {\n    this.arg = arg;\n    this.init();\n    this.package = 'WeatherLock\/package.json';\n    this.iphone = 'https:\/\/gitee.com\/script_djg\/scriptable\/raw\/master\/image\/phone.png';\n  }\n\n  init() {\n    this._actions = {};\n    this._actionsIcon = {};\n    this.SETTING_KEY = this.hash(Script.name());\n    \/\/ 文件管理器\n    this.FM = FileManager.local();\n    this.MGR_DOCU = this.FM.libraryDirectory();\n    \/\/ 用于模块存储\n    this.MODULE_FOLDER = this.FM.joinPath(\n      this.MGR_DOCU, 'module\/'\n    );\n    \/\/ 图片管理\n    this.IMAGE_FOLDER = this.FM.joinPath(\n      this.MGR_DOCU, 'images\/'\n    );\n    this.MGR_PATH = this.FM.joinPath(\n      this.MGR_DOCU, `${this.SETTING_KEY}\/`,\n    );\n    \/\/ 缓存管理\n    this.CACHE_DOCU = this.FM.cacheDirectory();\n    this.CACHE_PATH = this.FM.joinPath(\n      this.CACHE_DOCU, `${this.SETTING_KEY}\/`,\n    );\n    this.widgetConfig();\n    this.createDirectory();\n  }\n  \n  widgetConfig (flag = true) {\n    this.settings = flag ? this.getSettings() : {};\n    this.settings.refreshAfterDate = this.settings.refreshAfterDate || '30';\/\/ 数据刷新间隔\n    this.settings.fontColor = this.settings.fontColor || '#FFFFFF';\/\/ 字体颜色\n    this.settings.shadowColor = this.settings.shadowColor || '';\/\/ 字体阴影\n    this.settings.bgColor = this.settings.bgColor || '#008B8B';\/\/ 背景颜色\n  }\n  \n  createDirectory () {\n    this.FM.createDirectory(this.MODULE_FOLDER,true);\n    this.FM.createDirectory(this.IMAGE_FOLDER,true);\n    this.FM.createDirectory(this.MGR_PATH,true);\n    this.FM.createDirectory(this.CACHE_PATH,true);\n  }\n  \n  \/\/ 判断是否到达更新时间\n  isUpdata(cacheKey, useCache = true, time = parseInt(this.settings.refreshAfterDate)) {\n    time = time < 5 ? 5 : time;\n    let name = typeof useCache === 'string' ? useCache : this.name;\n    const nowTime = +new Date;\n    let lastTime = nowTime;\n    Keychain.contains(cacheKey) ? \n      lastTime = parseInt(Keychain.get(cacheKey)) : Keychain.set(cacheKey, String(lastTime));\n    let _lastTime = Math.floor((nowTime-lastTime)\/60000)\n    if(useCache) log(`${name}：缓存${_lastTime}分钟前，有效期${time}分钟`);\n    if(lastTime < (nowTime - 1000*60*time) || lastTime == nowTime) {\n      Keychain.set(cacheKey, String(nowTime));\n      return true;\n    }else { return false;}\n  }\n  \n  \/\/ 版本检测\n  async versionCheck () {\n    const url = this.getUrl(this.package);\n  \tlet versionData = await this.httpGet(url);\n    let req = versionData[this.ID];\n    if(req.version != this.version){\n      let title = \"新版本\"+req.version;\n      let message = req.notes + \"\\n\\n\" + req.updateTime;;\n      let idx = await this.generateAlert(message, ['立即更新','暂不更新'], title);\n      if (idx === 0) Safari.open(this.updata_info);\n    }else {\n      let title = \"暂无更新\";\n      let message = req.version + req.notes + \"\\n- 如无法预览，可尝试重置\\n- 也可在基础设置左上角查看\" + req.updateTime;\n      await this.generateAlert(message, ['知道了'], title);\n    }\n  }\n  \n  \/**\n   * 注册点击操作菜单\n   * @param {string} name 操作函数名\n   * @param {func} func 点击后执行的函数\n   *\/\n  registerAction(name, func, icon = { name: 'gearshape', color: '#FF6347' }) {\n    this._actions[name] = func.bind(this);\n    this._actionsIcon[name] = icon;\n  }\n  \n  \/**\n   * base64 编码字符串\n   * @param {string} str 要编码的字符串\n   *\/\n  base64Encode(str) {\n    const data = Data.fromString(str);\n    return data.toBase64String();\n  }\n\n  \/**\n   * base64解码数据 返回字符串\n   * @param {string} b64 base64编码的数据\n   *\/\n  base64Decode(b64) {\n    const data = Data.fromBase64String(b64);\n    return data.toRawString();\n  }\n\n  \/**\n   * hash 加密字符串\n   * @param {string} str 要加密成哈希值的数据\n   *\/\n  hash(string) {\n    let hash2 = 0, i, chr;\n    for (i = 0; i < string.length; i++) {\n      chr = string.charCodeAt(i);\n      hash2 = (hash2 << 5) - hash2 + chr;\n      hash2 |= 0;\n    }\n    return `hash_${hash2}`;\n  }\n  \n  getUrl(fileName) {\n    const repository = \"https:\/\/gitee.com\/script_djg\/scriptable\/raw\/master\/\";\n    return `${repository}${fileName}`;\n  }\n  \n  \/**\n   * HTTP 请求接口\n   * @param {string} url 请求的url\n   * @param {bool} useCache 是否采用离线缓存（请求失败后获取上一次结果）\n   * @param {bool} json 返回数据是否为 json，默认 true\n   * @return {string | json | null}\n   *\/\n  async httpGet (url, json = true, useCache = true, options = null, method = 'GET') {\n    let str = url + options?.headers?.cookie + options?.body;\n    let cacheKey = this.hash(str);\n    let cache = null;\n    if (this.isUpdata(cacheKey.slice(-8), useCache) || !Keychain.contains(cacheKey)){\n      try {\n        let req = new Request(url)\n        req.method = method\n        if(options){\n          Object.keys(options).forEach((key) => {\n            req[key] = options[key];\n          });\n        }\n        cache = await (json ? req.loadJSON() : req.loadString());\n      } catch (e) {console.error(`${this.name}：请求失败：${e}`)}\n    }\n    if(cache && useCache) {\n      this.saveStringCache(cacheKey, json ? JSON.stringify(cache) : cache);\n      return cache;\n    } else {\n      const localCache = this.loadStringCache(cacheKey);\n      return json ? JSON.parse(localCache) : localCache;\n    }\n  }\n  \n  loadStringCache(cacheKey, path = this.CACHE_PATH) {\n    const cacheFile = this.FM.joinPath(path, cacheKey);\n    const fileExists = this.FM.fileExists(cacheFile);\n    let cacheString = '';\n    if (fileExists) {\n      cacheString = this.FM.readString(cacheFile);\n    }\n    return cacheString;\n  }\n\n  saveStringCache(cacheKey, content, path = this.CACHE_PATH) {\n    const cacheFile = this.FM.joinPath(path, cacheKey);\n    this.FM.writeString(cacheFile, content);\n  }\n  \n  async getImageByUrl (url, path = this.CACHE_PATH) {\n    const cacheKey = this.hash(url);\n    let cacheImg = this.loadImgCache(cacheKey, path);\n    if (cacheImg != undefined && cacheImg != null) {\n      return cacheImg;\n    }\n    try {\n      const req = new Request(url)\n      cacheImg = await req.loadImage()\n      \/\/ 存储到缓存\n      this.saveImgCache(cacheKey, cacheImg, path);\n      return cacheImg;\n    } catch (e) {\n      console.error(e);\n      \/\/ 没有缓存+失败情况下，返回自定义的绘制图片（红色背景）\n      let ctx = new DrawContext()\n      ctx.size = new Size(100, 100)\n      ctx.setFillColor(Color.red())\n      ctx.fillRect(new Rect(0, 0, 100, 100))\n      return await ctx.getImage()\n    }\n  }\n  \n  saveImgCache(cacheKey, img, path) {\n    const cacheFile = this.FM.joinPath(path, `${cacheKey}.png`);\n    this.FM.writeImage(cacheFile, img);\n  }\n\n  loadImgCache(cacheKey, path) {\n    const cacheFile = this.FM.joinPath(path, `${cacheKey}.png`);\n    const fileExists = this.FM.fileExists(cacheFile);\n    let img = undefined;\n    if (fileExists) {\n      img = Image.fromFile(cacheFile);\n    }\n    return img;\n  }\n  \n  \/**\n   * @description 导入模块，不存在即下载模块\n   * @param {string} moduleName 模块名module\/faqTable.js\n   *\/\n  async require (moduleName) {\n    const path = this.MODULE_FOLDER;\n    const cacheKey = `${moduleName}.js`;\n    let localCache = this.loadStringCache(cacheKey, path);\n    if (!localCache) {\n      const url = this.getUrl(`WeatherLock\/module\/${cacheKey}`);\n      let req = new Request(url);\n      localCache = await req.loadString();\n      if (localCache) this.saveStringCache(cacheKey, localCache, path);\n    }\n    if (localCache) {\n      moduleName = this.FM.joinPath(path, cacheKey);\n      return importModule(moduleName);\n    }\n  }\n  \n  \/**\n   * 背景高斯模糊\n   * @param {img} Image\n   * @param {blur} Int 模糊值\n   * @param {blur} Int 透明度\n   *\/\n  async blurImage(img, blur = this.settings.bgBlur, opacity = this.settings.bgBlurOpacity) {\n    const blurImage = await this.require(\"blurImage\");\n    return await blurImage(img, blur, opacity);\n  }\n  \n  \/**\n   * 给图片加一层半透明遮罩\n   * @param {Image} img 要处理的图片\n   * @param {string} color 遮罩背景颜色\n   * @param {float} opacity 透明度\n   *\/\n  async shadowImage (img, color = this.settings.bgColor, opacity = this.settings.bgOpacity) {\n    let ctx = new DrawContext();\n    \/\/ 获取图片的尺寸\n    ctx.size = img.size\n    ctx.drawImageInRect(img, new Rect(0, 0, img.size['width'], img.size['height']))\n    ctx.setFillColor(new Color(color, parseFloat(opacity)))\n    ctx.fillRect(new Rect(0, 0, img.size['width'], img.size['height']))\n    return ctx.getImage()\n  }\n  \n  \/\/ 图像裁剪\n  cropImage(img, rect) {\n    let draw = new DrawContext();\n    draw.size = new Size(rect.width, rect.height);\n    draw.drawImageAtPoint(img, new Point(-rect.x, -rect.y));\n    return draw.getImage();\n  }\n  \n  \/**\n   * 获取设备分辨率大小\n   * @returns {json}\n   *\/\n  getWidgetWidthSize() {\n    \/\/ 屏幕缩放比例\n    let screenScale = Device.screenScale()\n    return screenScale;\n  }\n  \n  \/\/ ######创建画布######\n  makeCanvas(size) {\n    this.fontColor = this.settings.fontColor;\n    this.shadowColor = this.settings.shadowColor;\n    this.bgColor = this.settings.bgColor;\n    const canvas = new DrawContext();\n    canvas.opaque = false;\n    canvas.respectScreenScale = true;\n    canvas.size = new Size(size.width, size.height);;\n    return canvas;\n  }\n  \/\/ ######画线######\n  drawLine(canvas, x1, y1, x2, y2, width, color = this.widgetColor){\n    const path = new Path()\n    path.move(new Point(Math.round(x1),Math.round(y1)))\n    path.addLine(new Point(Math.round(x2),Math.round(y2)))\n    canvas.addPath(path)\n    canvas.setStrokeColor(color)\n    canvas.setLineWidth(width)\n    canvas.strokePath()  \n  }\n  \n  \/\/ ######绘制文字#######  \n  drawText(canvas, x, y, width, height, text, font, fontsize, alignment, color=this.fontColor, opacity=1){\n    canvas.setFont(this.provideFont(font, fontsize))\n    canvas.setTextColor(new Color(color, opacity))\n    if(alignment == \"left\") {canvas.setTextAlignedLeft()}\n    if(alignment == \"center\") {canvas.setTextAlignedCenter()}\n    if(alignment == \"right\") {canvas.setTextAlignedRight()}\n    canvas.drawTextInRect(text, new Rect(x, y, width, height))  \n  }\n  \n  \/\/ ######画实心柱######\n  fillRect (canvas,x,y,width,height,cornerradio,color=this.fontColor){  \n    let path = new Path()  \n    let rect = new Rect(x, y, width, height)  \n    path.addRoundedRect(rect, cornerradio, cornerradio)  \n    canvas.addPath(path)  \n    canvas.setFillColor(color)  \n    canvas.fillPath()  \n  }\n  \n  \/\/ ######画实心园######\n  drawPoint(canvas,x1,y1,diaofPoint,color=this.fontColor){  \n    let currPath = new Path()\n    currPath.addEllipse(new Rect(x1, y1, diaofPoint, diaofPoint))\n    canvas.addPath(currPath)\n    canvas.setFillColor(color)\n    canvas.fillPath()  \n  }\n  \n  \/\/ 套壳\n  async shell (image) {\n    const iphoneImg = await this.getImageByUrl(this.iphone, this.IMAGE_FOLDER);\n    const size = iphoneImg.size;\n    const canvas = this.makeCanvas(size);\n    canvas.setFillColor(new Color(this.settings.bgColor));\n    canvas.fillRect(new Rect(0, 0, size.width, size.height));\n    canvas.drawImageAtPoint(image, new Point(93, 60));\n    canvas.drawImageAtPoint(iphoneImg, new Point(0, 0));\n    return canvas.getImage();\n  }\n  \n  \/**\n   * 获取图标\n   * @param {string} weather 天气描述\n   * @param {string} options weatherIcon｜weatherDesc｜weatherOneIcon\n   * @param {int} index 天气图标编号\n   * @return {string}\n   *\/\n  async getIcon(weather, options = \"weatherIcon\", index = 1) {\n    const weatherDes = await this.require(\"weatherInfo\");\n    let iconName = weatherDes()[options][weather];\n    switch (options) {\n      case 'weatherIcon':\n        if(!iconName) iconName = \"PARTLY_CLOUDY_DAY\";\n        let iconUrl = this.getUrl(`image\/weatherIcon\/icon${index}\/${iconName}.png`);\n        return await this.getImageByUrl(iconUrl);\n    }\n  }\n  \n  \/**\n   * @param message 描述内容\n   * @param options 按钮\n   * @returns {Promise<number>}\n   *\/\n  async generateAlert(message, options, title) {\n    let alert = new Alert();\n    title && (alert.title = title);\n    alert.message = title ? '\\n' + message : message;\n    if(options) {\n      for (const option of options) {\n        alert.addAction(option);\n      }\n    }\n    return await alert.presentAlert();\n  }\n  \n  \/\/ 输入菜单\n  async setCustomAction(title, desc, opt, flag = true, notify = true) {\n    const a = new Alert();\n    a.title = title;\n    a.message = !desc ? '' : '\\n'+desc;\n    Object.keys(opt).forEach((key) => {\n      flag ? a.addTextField(opt[key], this.settings[key]) : a.addTextField(opt[key], this.djgSettings[key]);\n    });\n    a.addAction('确定');\n    a.addCancelAction('取消');\n    const id = await a.presentAlert();\n    if (id === -1) return false;\n    const data = {};\n    Object.keys(opt).forEach(async (key, index) => {\n      let temp = a.textFieldValue(index);\n      data[key] = temp;\n    });\n    flag ? this.settings = { ...this.settings, ...data } : this.djgSettings = { ...this.djgSettings, ...data };\n    this.saveSettings(notify, flag);\n    return true;\n  };\n  \n  \/\/ * @param {flag} true 默认单选\n  async setChoiceAction(title, desc, opt, flag = true, choice = 'choiceAction') {\n    let caches = {};\n    const choiceData = this.settings[choice] || 'a';\n    choiceData.split('').map(a => {caches[a] = true})\n    const sign = 'abcdefghijklmnopqrstuvwxyz';\n    for(let i in opt) opt[i] = [sign[i], opt[i]]\n    const a = new Alert();\n    a.title = title;\n    a.message = desc;\n    opt.map(k => {\n      let _id = k[0]\n      let _name = k[1]\n      a.addAction(caches[_id] ? `${_name} ✅` : `${_name} ☑️`)\n    })\n    a.addCancelAction(\"完成设置\")\n    const id = await a.presentSheet();\n    if (id === -1) return this.saveSettings();\n    if(flag) {\n      this.settings[choice] = opt[id][0];\n      this.saveSettings();\n    }else {\n      let _arg = opt[id]\n      caches[_arg[0]] ? caches[_arg[0]] = false : caches[_arg[0]] = true\n      let _caches = []\n      for (let k in caches) {\n        if (caches[k]) {\n          _caches.push(k)\n        }\n      }\n      this.settings[choice] = _caches.join('');\n      for(let i in opt) opt[i] = opt[i][1];\n      await this.setChoiceAction(title, desc, opt, false);\n    }\n  };\n  \n  \/**\n   * 设置组件内容\n   * @returns {Promise<void>}\n   *\/\n  async setWidgetConfig() {\n    const table = new UITable();\n    table.showSeparators = true;\n    await this.renderDJGTables(table);\n    await table.present();\n  };\n  \n  async preferences(table, arrs, outfit) {\n    const header = new UITableRow();\n    const heading = header.addText(outfit);\n    heading.titleFont = Font.mediumSystemFont(17);\n    heading.centerAligned();\n    table.addRow(header);\n    for (const item of arrs) {\n      const row = new UITableRow();\n      if (item.explain) {\n        row.height = 36\n    \trow.backgroundColor = Color.dynamic(\n      \t  new Color('F2F1F6'),\n      \t  new Color('000000'),\n    \t);\n    \tconst title = row.addText(item.explain, ' ');\n    \ttitle.subtitleFont = Font.systemFont(7);\n        title.titleFont = Font.systemFont(13);\n    \ttitle.titleColor = Color.dynamic(\n      \t  new Color('000000', 0.6),\n      \t  new Color('FFFFFF', 0.6),\n    \t);\n      } else if (item.title) {\n      \trow.dismissOnSelect = !!item.dismissOnSelect;\n      \tif (item.url) {\n          const img = await this.getImageByUrl(item.url, this.IMAGE_FOLDER);\n          const rowIcon = row.addImage(img)\n          rowIcon.widthWeight = 100;\n      \t}\n      \tif (item.icon) {\n          const icon = item.icon || {};\n          const image = await this.drawTableIcon(icon.name, icon.color, item.cornerWidth);\n          const imageCell = row.addImage(image);\n          imageCell.widthWeight = 100;\n      \t}\n      \tconst rowTitle = row.addText(item.title);\n      \trowTitle.widthWeight = 400;\n      \trowTitle.titleFont = Font.systemFont(16);\n        let isArray = Array.isArray(item.val);\n      \tif (item.val) {\n          const valText = row.addText(`${item.val}`.toUpperCase());\n          valText.widthWeight = 500;\n          valText.rightAligned();\n          valText.titleColor = Color.blue();\n          valText.titleFont = Font.mediumSystemFont(16);\n      \t} else {\n          const url = \"https:\/\/gitee.com\/scriptxx_djg\/imgebed\/raw\/master\/menu\/Ue5thScBQAMJ.png\";\n          const img = await this.getImageByUrl(url, this.IMAGE_FOLDER);\n          const imgCell = UITableCell.image(img)\n          imgCell.rightAligned();\n          imgCell.widthWeight = 500;\n          row.addCell(imgCell);\n      \t}\n      \tif (item.onClick) row.onSelect = () => item.onClick(item, row);\n      }\n      table.addRow(row);\n    }\n    table.reload();\n  };\n  \n  async drawTableIcon (icon = 'square.grid.2x2', color = '#FF7F00', cornerWidth = 42) {\n    const cacheKey = this.hash(icon + color);\n    let img = this.loadImgCache(cacheKey, this.IMAGE_FOLDER);\n    if(img) return img;\n    \n    const sfi = SFSymbol.named(icon);\n    sfi.applyFont(Font.mediumSystemFont(30));\n    const imgData = Data.fromPNG(sfi.image).toBase64String();\n    const html = `\n    <img id=\"sourceImg\" src=\"data:image\/png;base64,${imgData}\" \/>\n    <img id=\"silhouetteImg\" src=\"\" \/>\n    <canvas id=\"mainCanvas\" \/>`;\n    const js = `\n    var canvas = document.createElement(\"canvas\");\n    var sourceImg = document.getElementById(\"sourceImg\");\n    var silhouetteImg = document.getElementById(\"silhouetteImg\");\n    var ctx = canvas.getContext('2d');\n    var size = sourceImg.width > sourceImg.height ? sourceImg.width : sourceImg.height;\n    canvas.width = size;\n    canvas.height = size;\n    ctx.drawImage(sourceImg, (canvas.width - sourceImg.width) \/ 2, (canvas.height - sourceImg.height) \/ 2);\n    var imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    var pix = imgData.data;\n    \/\/ 将图像转换为剪影\n    for (var i=0, n = pix.length; i < n; i+= 4){\n      \/\/set red to 0 设置为红色到0\n      pix[i] = 255;\n      \/\/set green to 0 设置绿色到0\n      pix[i+1] = 255;\n      \/\/set blue to 0 设置为蓝色到0\n      pix[i+2] = 255;\n      \/\/retain the alpha value 保留阿尔法值\n      pix[i+3] = pix[i+3];\n    }\n    ctx.putImageData(imgData,0,0);\n    silhouetteImg.src = canvas.toDataURL();\n    output=canvas.toDataURL()`;\n    let wv = new WebView();\n    await wv.loadHTML(html);\n    const base64Image = await wv.evaluateJavaScript(js);\n    const iconImage = await new Request(base64Image).loadImage();\n    const image = iconImage;\n    \n    const size = new Size(160, 160);\n    const ctx = new DrawContext();\n    ctx.opaque = false;\n    ctx.respectScreenScale = true;\n    ctx.size = size;\n    const path = new Path();\n    const rect = new Rect(0, 0, size.width, size.width);\n\n    path.addRoundedRect(rect, cornerWidth, cornerWidth);\n    path.closeSubpath();\n    ctx.setFillColor(new Color(color));\n    ctx.addPath(path);\n    ctx.fillPath();\n    const rate = 36;\n    const iw = size.width - rate;\n    const x = (size.width - iw) \/ 2;\n    ctx.drawImageInRect(image, new Rect(x, x, iw, iw));\n    \n    img = ctx.getImage();\n    this.saveImgCache(cacheKey, img, this.IMAGE_FOLDER);\n    return img;\n  };\n  \n  async renderDJGTables(table) {\n    const basicSettings = [\n      {\n        title: '刷新间隔',\n        val: this.settings.refreshAfterDate,\n        icon: {name: \"arrow.clockwise\", color: \"#1890ff\"},\n        onClick: async () => {\n          await this.setCustomAction(\n            '刷新间隔',\n            '数据刷新间隔，避免频繁访问报错，单位：分钟', {\n              refreshAfterDate: '刷新间隔',\n            }\n          );\n        }\n      },\n      {\n        title: \"字体颜色\",\n        icon: {name: \"photo.fill\", color: \"#d48806\"},\n        onClick: async () => {\n          await this.setCustomAction(\"字体颜色\", \"请自行百度搜寻颜色(Hex 颜色)\", {fontColor:'字体颜色'});\n       }\n      },\n      {\n        title: \"背景颜色\",\n        icon: {name: \"photo.on.rectangle\", color: \"#fa8c16\"},\n        onClick: async () => {\n          await this.setCustomAction(\"背景颜色\", \"请自行百度搜寻颜色(Hex 颜色)\", {bgColor:'背景颜色'});\n        }\n      }\n    ];\n    table.removeAllRows();\n    let topRow = new UITableRow();\n    let buttonCell1 = topRow.addButton('常见问题');\n    buttonCell1.widthWeight = 0.25;\n    buttonCell1.onTap = async () => {\n      const faqTable = await this.require('faqTable_Weather');\n      await faqTable();\n    }\n    let buttonCell4 = topRow.addButton('TG交流群');\n    buttonCell4.widthWeight = 0.25;\n    buttonCell4.rightAligned();\n    buttonCell4.onTap = async () => {\n      await Safari.open('https:\/\/t.me\/+ViT7uEUrIUV0B_iy');\n    }\n    table.addRow(topRow);\n    let header = new UITableRow();\n    let heading = header.addText('还原设置');\n    heading.titleFont = Font.mediumSystemFont(17);\n    heading.centerAligned();\n    table.addRow(header);\n    let row1 = new UITableRow();\n    let rowtext1 = row1.addText(\n      '重置缓存',\n      '若数据显示错误，可尝试此操作',\n    );\n    rowtext1.titleFont = Font.systemFont(16);\n    rowtext1.subtitleFont = Font.systemFont(12);\n    rowtext1.subtitleColor = new Color('999999');\n    row1.onSelect = async () => {\n      const option = ['取消', '重置'];\n      const message = '所有在线请求的数据缓存将会被清空！\\n重置成功后\\n请重新运行此桌面小组件！';\n      const index = await this.generateAlert(message, option);\n      if (index === 0) return;\n      this.FM.remove(this.CACHE_PATH);\n      this.FM.remove(this.MODULE_FOLDER);\n      this.createDirectory();\n      this.notify('重置缓存成功', '请重新运行此桌面小组件！');\n    };\n    table.addRow(row1);\n    let row2 = new UITableRow();\n    let rowtext2 = row2.addText(\n      '还原设置参数',\n      '若需要恢复默认参数，可尝试此操作',\n    );\n    rowtext2.titleFont = Font.systemFont(16);\n    rowtext2.subtitleFont = Font.systemFont(12);\n    rowtext2.subtitleColor = new Color('999999');\n    row2.onSelect = async () => {\n      const option = ['取消', '重置'];\n      const message = '基础设置中的所有参数将会重置为默认值，重置后请重新打开设置菜单！';\n      const index = await this.generateAlert(message, option);\n      if (index === 0) return;\n      this.widgetConfig(false);\n      this.saveSettings(false);\n      this.notify('还原设置成功', '请重新运行此桌面小组件！');\n    };\n    table.addRow(row2);\n    await this.preferences(table, basicSettings, '基础设置');\n    let imgRow = new UITableRow();\n\n  }\n  \n  \/**\n   * 弹出一个通知\n   * @param {string} title 通知标题\n   * @param {string} body 通知内容\n   * @param {string} url 点击后打开的URL\n   *\/\n  async notify(title, body, opts = {openURL:\"\", sound:\"alert\"}) {\n    try {\n      let n = new Notification();\n      n = Object.assign(n, opts);\n      n.title = title;\n      n.body = body;\n      return await n.schedule();\n    } catch (e) {throw new Error(e)}\n  }\n\n  \/**\n   * 获取当前插件的设置\n   * @param {boolean} json 是否为json格式\n   *\/\n  getSettings(json = true, flag = true) {\n    let res = json ? {} : '';\n    let key = flag ? this.SETTING_KEY : this.DJG_KEY;\n    let cache = '';\n    if (Keychain.contains(key)) {\n      cache = Keychain.get(key);\n    }\n    if (json) {\n      try {\n        res = JSON.parse(cache);\n      } catch (e) {}\n    } else {\n      res = cache;\n    }\n    return res;\n  }\n\n  \/**\n   * 存储当前设置\n   * @param {bool} notify 是否通知提示\n   *\/\n  saveSettings(notify = true, flag = true) {\n    let key = flag ? this.SETTING_KEY : this.DJG_KEY;\n    let setDemo = flag ? this.settings : this.djgSettings;\n    let res =\n      typeof setDemo === 'object'\n        ? JSON.stringify(setDemo)\n        : String(setDemo);\n    Keychain.set(key, res);\n    if (notify) this.notify('设置成功', '桌面组件稍后将自动刷新');\n  }\n  \n  \/**\n   * 获取定位\n   * @param {bool} flag 执行获取定位，默认 false\n   *\/\n  async getLocation(time = this.djgSettings.locTime || '30') {\n    let data = null;\n    const isInApp = config.runsInApp;\n    const cacheKey = 'DJG_location';\n    if (!Keychain.contains(cacheKey) || this.isUpdata('locUPtime', \"位置获取\", parseInt(time))) {\n      if (isInApp) this.notify('正在获取位置', '此组件需要获取位置信息\\n请耐心等待几秒');\n      try {\n        const location = await Location.current();\n        const geocode = await Location.reverseGeocode(location.latitude, location.longitude, Device.locale());\n        data = geocode[0];\n      }catch(e){\n      \tconsole.error(`${this.name}：${e}`);\n      \tif (isInApp) await this.generateAlert('请检查位置权限或网络设置', ['知道了'], '定位失败');\n      };\n    }\n    if(data) {\n      Keychain.set(cacheKey, JSON.stringify(data));\n      if (isInApp) this.notify('位置获取成功', '桌面组件将稍后刷新。');\n    }else if (!data && Keychain.contains(cacheKey)) {\n      data = JSON.parse(Keychain.get(cacheKey));\n    }\n    return data;\n  }\n  \n  \/**\n   * 匹配地址\n   * @param {string} location 详细地址\n   * @param {string} match 区域\n   * @return string\n   *\/\n  getAddress (location, match = '区') {\n    const matchs = ['省','壮族自治区','回族自治区','自治州','维吾尔自治区','自治区','市','区','路'];\n    let index = matchs.findIndex(item =>{\n      return item == match\n    })\n    let regStr = '';\n    for(let i = 0; i < index+1; i++){\n      regStr = i === 0 ? matchs[i] : `${regStr}|${matchs[i]}`;\n    }\n    let address = null;\n    let citys = location.split(' ');\n    let reg = RegExp(eval(`\/${regStr}\/g`));\n    citys.forEach(function (item, index) {\n      const str = citys[index].match(reg);\n      if (str){\n        address = citys[index];\n      }\n    })\n    return address||location.split(' ')[1];\n\n  }\n  \n  provideFont(fontName, fontSize) {\n    const fontGenerator = {\n      ultralight: function () {return Font.ultraLightSystemFont(fontSize)},\n      light: function () {return Font.lightSystemFont(fontSize)},\n      regular: function () {return Font.regularSystemFont(fontSize)},\n      medium: function () {return Font.mediumSystemFont(fontSize)},\n      semibold: function () {return Font.semiboldSystemFont(fontSize)},\n      bold: function () {return Font.boldSystemFont(fontSize)},\n      heavy: function () {return Font.heavySystemFont(fontSize)},\n      black: function () {return Font.blackSystemFont(fontSize)},\n      italic: function () {return Font.italicSystemFont(fontSize)},\n      lightMonospaced: function () {return Font.lightMonospacedSystemFont(fontSize)},\n      boldRounded: function () {return Font.boldRoundedSystemFont(fontSize)},\n    }\n    const systemFont = fontGenerator[fontName];\n    if (systemFont) {return systemFont()}\n    return new Font(fontName, fontSize);\n  };\n  \n  \/**\n    * 格式化时间\n    * @param {Date} date 日期\n    * @param {DateFormatter} formatter 格式化\n    * @param {string} locale 地区\n    *\/\n  getDateStr(date = new Date(), formatter = \"yyyy年MM月d日 EEE\", locale = \"zh_cn\") {\n    const df = new DateFormatter()\n    df.locale = locale\n    df.dateFormat = formatter\n    return df.string(date)\n  }\n  \n  getTimeNum(time){\n  \tif (!time) return +new Date;\n  \tlet date = new Date(time)\n  \treturn Date.parse(date);\n  }\n}\n\n\/\/ @base.end\nconst Runing = async (Weather) => {\n  let M = null;\n  if (config.runsInApp) {\n    log(`[+] 锁屏天气`)\n    log(`[\/] 当前环境：${RUNTIME_VERSION}`)\n    M = new Weather();\n    \/\/ 弹出选择菜单\n    const actions = M['_actions'];\n    const table = new UITable();\n    const onClick = async (item) => {\n      image = await M.render();\n      image = await M.shell(image);\n      QuickLook.present(image, false);\n    };\n    const preview = [\n      {\n        icon: {name: \"photo.tv\", color: \"#1890ff\"},\n        title: '效果预览',\n        onClick,\n      }\n    ];\n    let topRow = new UITableRow();\n    topRow.height = 60;\n    let leftText = topRow.addButton('脚本仓库');\n    leftText.widthWeight = 0.3;\n    leftText.onTap = async () => {\n      await Safari.open('https:\/\/gitee.com\/script_djg\/scriptable');\n    };\n    let centerRow = topRow.addImage(await M.getImageByUrl('https:\/\/raw.githubusercontent.com\/58xinian\/icon\/master\/Github.png', M.IMAGE_FOLDER)); \/\/ 上中小图\n    centerRow.widthWeight = 0.4;\n    centerRow.centerAligned();\n    let rightText = topRow.addButton('更新检测');\n    rightText.widthWeight = 0.3;\n    rightText.rightAligned();\n    rightText.onTap = async () => {\n      await M.versionCheck();\n    };\n    table.addRow(topRow)\n    await M.preferences(table, preview, '锁屏天气');\n    const extra = [];\n    for (let _ in actions) {\n      const iconItem = M._actionsIcon[_];\n      const isUrl = typeof iconItem === 'string';\n      const actionItem = {\n        title: _,\n        onClick: actions[_],\n      };\n      if (isUrl) {\n        actionItem.url = iconItem;\n      } else {\n        actionItem.icon = iconItem;\n      }\n      extra.push(actionItem);\n    }\n    await M.preferences(table, extra, '配置组件');\n    let imgRow = new UITableRow();\n    imgRow.height = 200;\n    table.addRow(imgRow);\n    return table.present();\n  } else {\n    M = new Weather(args.shortcutParameter);\n    const image = await M.render();\n    if (image) {\n      const imgData = Data.fromPNG(image).toBase64String();\n      Script.setShortcutOutput(imgData);\n      Script.complete();\n    }\n  }\n};\n\/\/  await new DJG().setWidgetConfig();\nmodule.exports = { DJG, Runing };  ",
  "share_sheet_inputs" : [

  ]
}